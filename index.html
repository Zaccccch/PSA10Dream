<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>PSA10Dream - 手机全屏版</title>
    <script async src="https://docs.opencv.org/4.x/opencv.js" type="text/javascript"></script>
    <style>
        :root { --bg: #000000; --panel: rgba(47, 49, 54, 0.85); --accent: #007bff; }
        * { touch-action: none; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body { margin: 0; padding: 0; height: 100vh; background: var(--bg); color: white; font-family: sans-serif; overflow: hidden; position: fixed; width: 100%; }

        /* 全屏画布区 */
        #main { width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; position: relative; z-index: 1; }
        canvas { max-width: 100%; max-height: 100%; object-fit: contain; }

        /* 顶部状态条 */
        #top-bar { position: absolute; top: 10px; left: 10px; right: 10px; z-index: 10; display: flex; align-items: center; pointer-events: none; }
        .status-pill { background: rgba(0,0,0,0.6); padding: 5px 12px; border-radius: 20px; display: flex; align-items: center; font-size: 12px; }
        .light { width: 8px; height: 8px; border-radius: 50%; background: #ff4d4d; margin-right: 6px; }
        .light.ready { background: #2ecc71; box-shadow: 0 0 5px #2ecc71; }

        /* 底部悬浮控制台 */
        #control-panel { position: absolute; bottom: 20px; left: 10px; right: 10px; background: var(--panel); backdrop-filter: blur(10px); padding: 15px; border-radius: 15px; z-index: 10; display: flex; flex-direction: column; gap: 8px; box-shadow: 0 -5px 15px rgba(0,0,0,0.3); }
        .btn-group { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        
        button { border: none; border-radius: 8px; padding: 12px; font-weight: bold; font-size: 14px; color: white; background: #4f545c; }
        button:active { opacity: 0.7; }
        button.primary { background: var(--accent); }
        button.save { background: #28a745; }

        /* 数值显示面板 - 悬浮在右上角 */
        #value-panel { position: absolute; top: 50px; right: 10px; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 8px; font-size: 12px; pointer-events: none; display: none; z-index: 5; }
        .val-row { display: flex; justify-content: space-between; gap: 15px; margin: 2px 0; }

        /* 隐藏说明文字，手机空间宝贵，改为弹窗提示 */
        .hint { font-size: 11px; color: #ccc; text-align: center; margin-top: 5px; }
    </style>
</head>
<body>

<div id="top-bar">
    <div class="status-pill">
        <div id="status-light" class="light"></div>
        <span id="status-text">OpenCV 加载中...</span>
    </div>
</div>

<div id="value-panel">
    <div class="val-row"><span>左 (L):</span><span id="v-l">0</span></div>
    <div class="val-row"><span>右 (R):</span><span id="v-r">0</span></div>
    <div class="val-row"><span>上 (T):</span><span id="v-t">0</span></div>
    <div class="val-row"><span>下 (B):</span><span id="v-b">0</span></div>
</div>

<div id="main">
    <canvas id="canvas"></canvas>
</div>

<div id="control-panel">
    <div class="btn-group">
        <button class="primary" onclick="handleOpenImage()">打开图片</button>
        <button onclick="location.reload()">重置应用</button>
    </div>
    <div id="stage-controls" style="display: none;" class="btn-group">
        <button class="primary" id="main-action-btn" onclick="doRectify()">执行矫正</button>
        <button id="sub-action-btn" onclick="enterStage2()">测距模式</button>
    </div>
    <button class="save" id="save-btn" style="display: none;" onclick="saveImage()">保存结果图</button>
    <div class="hint" id="hint-text">请在图上点击卡片的四个角</div>
</div>

<input type="file" id="fileInput" accept="image/*" style="display:none">

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let imgOrig = null, matOrig = null, matRectified = null;
    let stage = 1, points1 = [], points2 = [], isCollecting2 = false, lines = null, dragging = null;
    let isCvLoaded = false;

    var Module = {
        onRuntimeInitialized: () => {
            isCvLoaded = true;
            document.getElementById('status-light').className = 'light ready';
            document.getElementById('status-text').innerText = 'OpenCV 已就绪';
        }
    };

    function handleOpenImage() { if(isCvLoaded) document.getElementById('fileInput').click(); else alert("等待OpenCV..."); }

    document.getElementById('fileInput').onchange = (e) => {
        const file = e.target.files[0];
        if(!file) return;
        const reader = new FileReader();
        reader.onload = (ev) => {
            imgOrig = new Image();
            imgOrig.onload = () => {
                canvas.width = imgOrig.width;
                canvas.height = imgOrig.height;
                if(matOrig) matOrig.delete();
                matOrig = cv.imread(imgOrig);
                stage = 1; points1 = []; points2 = []; lines = null;
                document.getElementById('stage-controls').style.display = 'grid';
                document.getElementById('hint-text').innerText = "请依次点击卡片的四个角";
                redraw();
            };
            imgOrig.src = ev.target.result;
        };
        reader.readAsDataURL(file);
    };

    function getEventPos(e) {
        const rect = canvas.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        // 核心修复：计算相对于显示尺寸的比例，再映射回原始像素
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        return {
            x: (clientX - rect.left) * scaleX,
            y: (clientY - rect.top) * scaleY
        };
    }

    canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const pos = getEventPos(e);
        if (stage === 1 && points1.length < 4) {
            points1.push(pos);
        } else if (stage === 2) {
            if (isCollecting2) {
                points2.push(pos);
                if (points2.length === 4) {
                    lines = { left: Math.min(...points2.map(p=>p.x)), right: Math.max(...points2.map(p=>p.x)), top: Math.min(...points2.map(p=>p.y)), bottom: Math.max(...points2.map(p=>p.y)) };
                    isCollecting2 = false;
                    document.getElementById('value-panel').style.display = 'block';
                    document.getElementById('hint-text').innerText = "长按并滑动黄线可微调";
                }
            } else if (lines) {
                const tol = 50; // 手机端增加触摸灵敏度
                if (Math.abs(pos.x - lines.left) < tol) dragging = 'left';
                else if (Math.abs(pos.x - lines.right) < tol) dragging = 'right';
                else if (Math.abs(pos.y - lines.top) < tol) dragging = 'top';
                else if (Math.abs(pos.y - lines.bottom) < tol) dragging = 'bottom';
            }
        }
        redraw();
    }, {passive: false});

    canvas.addEventListener('touchmove', (e) => {
        if (!dragging || !lines) return;
        const pos = getEventPos(e);
        if (dragging === 'left' || dragging === 'right') lines[dragging] = pos.x;
        else lines[dragging] = pos.y;
        redraw();
    }, {passive: false});

    canvas.addEventListener('touchend', () => dragging = null);

    function doRectify() {
        if (points1.length !== 4) return alert("请先点满4个角");
        let srcPts = cv.matFromArray(4, 1, cv.CV_32FC2, points1.flatMap(p => [p.x, p.y]));
        const w = Math.max(Math.hypot(points1[1].x-points1[0].x, points1[1].y-points1[0].y), Math.hypot(points1[2].x-points1[3].x, points1[2].y-points1[3].y));
        const h = Math.max(Math.hypot(points1[3].x-points1[0].x, points1[3].y-points1[0].y), Math.hypot(points1[2].x-points1[1].x, points1[2].y-points1[1].y));
        let dstPts = cv.matFromArray(4, 1, cv.CV_32FC2, [0, 0, w, 0, w, h, 0, h]);
        let M = cv.getPerspectiveTransform(srcPts, dstPts);
        if (matRectified) matRectified.delete();
        matRectified = new cv.Mat();
        cv.warpPerspective(matOrig, matRectified, M, new cv.Size(w, h));
        canvas.width = w; canvas.height = h;
        stage = 2; isCollecting2 = true; points2 = []; lines = null;
        document.getElementById('main-action-btn').innerText = "重选测距点";
        document.getElementById('main-action-btn').onclick = enterStage2;
        document.getElementById('save-btn').style.display = 'block';
        document.getElementById('hint-text').innerText = "点选卡片内边框的四个角点";
        redraw();
        srcPts.delete(); dstPts.delete(); M.delete();
    }

    function redraw() {
        if (stage === 1 && matOrig) { cv.imshow(canvas, matOrig); draw1(); }
        else if (stage === 2 && matRectified) { cv.imshow(canvas, matRectified); draw2(); }
    }

    function draw1() {
        ctx.fillStyle = "#00ff00";
        points1.forEach((p, i) => {
            ctx.beginPath(); ctx.arc(p.x, p.y, canvas.width/50, 0, Math.PI*2); ctx.fill();
        });
    }

    function draw2() {
        if (isCollecting2) {
            ctx.fillStyle = "#00ff00";
            points2.forEach(p => { ctx.beginPath(); ctx.arc(p.x, p.y, canvas.width/60, 0, Math.PI*2); ctx.fill(); });
        } else if (lines) {
            ctx.strokeStyle = "#ffff00"; ctx.lineWidth = canvas.width/150;
            ctx.beginPath(); ctx.moveTo(lines.left, 0); ctx.lineTo(lines.left, canvas.height); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(lines.right, 0); ctx.lineTo(lines.right, canvas.height); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(0, lines.top); ctx.lineTo(canvas.width, lines.top); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(0, lines.bottom); ctx.lineTo(canvas.width, lines.bottom); ctx.stroke();
            
            document.getElementById('v-l').innerText = lines.left.toFixed(1);
            document.getElementById('v-r').innerText = (canvas.width - lines.right).toFixed(1);
            document.getElementById('v-t').innerText = lines.top.toFixed(1);
            document.getElementById('v-b').innerText = (canvas.height - lines.bottom).toFixed(1);
        }
    }

    function enterStage2() { isCollecting2 = true; points2 = []; lines = null; document.getElementById('value-panel').style.display = 'none'; redraw(); }
    function saveImage() { const a = document.createElement('a'); a.download = 'PSA_Result.png'; a.href = canvas.toDataURL(); a.click(); }
</script>
</body>
</html>
